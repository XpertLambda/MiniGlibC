# TP Programmation Syst√®me

## MINI_LIB 

### **Macros**

| Macro          | Value                        | Comments                                      |
|----------------|------------------------------|-----------------------------------------------|
| `MEM_FAIL`     | "Memory allocation failed"   | Indicates memery fail message 				|
| `USED`         | 1                            | Indicates memory is currently used            |
| `FREE`         | 0                            | Indicates memory is free                      |
| `NOT_INIT`     | -1                           | Indicates uninitialized state                 |
| `BUF_SIZE`     | 1024                         | Size of the buffer                            |
| `ERROR_MAX`    | 256                          |                                               |
| `IOBUFFER_SIZE`| 2048                         | Size of input/output buffer                   |
| `MAX_ARGS`     | 64                           | Maximum number of arguments in a command      |
| `MAX_PATH`     | 4096                         | Suitable buffer size for path                 |

### **Structures**
```c
typedef struct malloc_element{
	void* zone;  // Pointer to the allocated memory block
	size_t total_size;  // Size of the allocated block
	int status;  // Status of the memory (USED/FREE)
	struct malloc_element* next_malloc;  // Pointer to next memory block
} malloc_element;

typedef struct MYFILE{
	int fd;  // File descriptor
	void* buffer_read;  // Pointer to read buffer
	void* buffer_write;  // Pointer to write buffer
	int ind_read;  // Read buffer index
	int ind_write;  // Write buffer index
	struct MYFILE *next;  // Pointer to next file in the open file list
} MYFILE;
```



### **Functions**
**I've created more functions than needed. Adjusted some existant. <br>
They're in <span style="color:red">red** </span>

| Function Signature                                       | Explanation                                                        |
|----------------------------------------------------------|--------------------------------------------------------------------|
| `void* mini_calloc(int size_element, int number_element)`| Allocates memory for an array of elements and initializes it to zero. <br> @size_element: Size of each element. <br> @number_element: Number of elements to allocate. <br> @return: Pointer to the allocated memory or NULL on failure. |
| `void mini_free(void* ptr)`                              | Frees the memory block pointed to by ptr. <br> @ptr: Pointer to the memory block to be freed. |
| `void mini_exit(int status)`                             | Terminates the program and cleans up. <br> @status: Exit status code. |
| <span style="color:red">`void real_mini_printf(char* args[])`</span>                    | Prints a string to the standard output. <br> @args: The array of strings to be printed. |
| `int mini_scanf(char* buffer, int size_buffer)`          | Reads input from standard input into the provided buffer. <br> @buffer: The buffer to store the input. <br> @size_buffer: Size of the buffer. <br> @return: The number of characters read. |
| <span style="color:red">`int mini_strnlen(char* s, size_t max_len)`</span>               | Returns the length of the string up to a maximum number of characters. <br> @s: The string to measure. <br> @max_len: Maximum number of characters to measure. |
| <span style="color:red">`int mini_strncpy(char* s, char* d, size_t dest_size)`</span>    | Copies a string to a destination buffer. <br> @s: Source string. <br> @d: Destination buffer. <br> @dest_size: Size of the destination buffer. |
| <span style="color:red">`int mini_strncmp(char* s1, char* s2, size_t max_len)`</span>    | Compares two strings up to a maximum length. <br> @s1: First string. <br> @s2: Second string. <br> @max_len: Maximum number of characters to compare. |
| `int mini_strlen(char* s)`              | Returns the length of the string up to a maximum number of characters. <br> @s: The string to measure. <br> |
| `int mini_strcpy(char* s, char* d)`    | Copies a string to a destination buffer. <br> @s: Source string. <br> @d: Destination buffer. |
| `int mini_strcmp(char* s1, char* s2)`    | Compares two strings up to a maximum length. <br> @s1: First string. <br> @s2: Second string. |
| `void mini_perror(char* message)`                        | Prints an error message to standard error. <br> @message: The error message to print. |
| <span style="color:red">`char* mini_strtok(char *str, const char *delim)`</span>  | A custom strtok function that tokenizes strings based on given delimiters. <br> @str: The string to tokenize; pass NULL to continue tokenizing the previous string. <br> @delim: The delimiters used to split the string. <br> @return: A pointer to the next token, or NULL if there are no more tokens. |
| <span style="color:red">`char* mini_strchr(const char *s, int c)`</span>  | Finds the first occurrence of any of the characters in `delim` in the string `s`. <br> @s: The string to search. <br> @delim: The characters to search for. <br> @return: A pointer to the first occurrence of any character in `delim`, or NULL if none found. |
| <span style="color:red">`int mini_atoi(char *s)`</span>                                 | Converts a string to an integer. <br> @s: String to convert. |
| <span style="color:red">`int mini_strstr(char* word1, char* word2)`</span>               | Finds the first occurrence of the substring `word2` in `word1`. <br> @word1: Main string. <br> @word2: Substring to find. |
| `int mini_fread(void* buffer, int size_element, int number_element, MYFILE *file)` | Reads data from a file into a buffer. <br> @buffer: Buffer to store data. <br> @size_element: Size of each element. <br> @number_element: Number of elements to read. <br> @file: File pointer. |
| `int mini_fwrite(void* buffer, int size_element, int number_element, MYFILE *file)`| Writes data from a buffer to a file. <br> @buffer: Buffer containing data. <br> @size_element: Size of each element. <br> @number_element: Number of elements to write. <br> @file: File pointer. |
| `int mini_fflush(MYFILE* file)`                           | Flushes the write buffer of a file. <br> @file: File pointer to flush. |
| `void add_to_open_file_list(MYFILE *file)`                | Adds a file to the open file list. <br> @file: File to add. |
| `void remove_from_open_file_list(MYFILE *file)`           | Removes a file from the open file list. <br> @file: File to remove. |
| `int mini_fclose(MYFILE* file)`                           | Closes an open file. <br> @file: File pointer to close. |
| `int mini_fgetc(MYFILE* file)`                            | Reads a character from a file. <br> @file: File pointer. |
| `int mini_fputc(MYFILE* file, char c)`                    | Writes a character to a file. <br> @file: File pointer. <br> @c: Character to write. |
| `void mini_touch(char* file_name)`                        | Creates a new file or updates the timestamp of an existing file. <br> @file_name: Name of the file. |
| `void mini_cp(char* src, char* dest)`                     | Copies a file from `src` to `dest`. <br> @src: Source file path. <br> @dest: Destination file path. |
| `void mini_cat(char* file_name)`                          | Displays the content of a file. <br> @file_name: Name of the file. |
| `void mini_head(char* file_name, int N)`                  | Displays the first `N` lines of a file. <br> @file_name: Name of the file. <br> @N: Number of lines to display. |
| `void mini_tail(char* file_name, int N)`                  | Displays the last `N` lines of a file. <br> @file_name: Name of the file. <br> @N: Number of lines to display. |
| `void mini_clean(char* file_name)`                        | Deletes all content in a file without removing the file. <br> @file_name: Name of the file. |
| `void mini_wc(char *file_name)`                           | Counts the number of lines, words, and characters in a file. <br> @file_name: Name of the file. |
| `void mini_echo(char* chaine)`                            | Outputs the string to the console. <br> @chaine: String to output. |
| `void mini_grep(char* word, char* file_name)`             | Searches for `word` in the file `file_name`. <br> @word: Word to search for. <br> @file_name: File to search in. |
| `void mini_ls(char *path)`                                | Lists all files and directories at the specified path. <br> @path: Path to list. |
| `void mini_chmod(char *file, int mode)`                   | Changes the mode (permissions) of a file. <br> @file: File whose permissions to change. <br> @mode: New permissions. |
| `void mini_mkdir(char *path)`                             | Creates a new directory. <br> @path: Path of the new directory. |
| `void mini_mv(char *oldpath, char *newpath)`              | Moves or renames a file from `oldpath` to `newpath`. <br> @oldpath: Current path of the file. <br> @newpath: New path of the file. |
| `void mini_rm(char *file)`                                | Removes a file. <br> @file: File to remove. |
| `void mini_rmdir(char *path)`                             | Removes a directory. <br> @path: Directory to remove. |
| `void mini_quickdiff(char *file1, char *file2)`           | Compares two files and displays differences. <br> @file1: First file. <br> @file2: Second file. |
| `void mini_cd(char *path)`                                | Changes the current directory. <br> @path: New directory path. |
| `void mini_env()`                                         | Displays all environment variables. |
| `void mini_getenv(char *name)`                            | Retrieves the value of an environment variable. <br> @name: Name of the variable. |
| `void mini_export(char *var)`                             | Adds or modifies an environment variable. <br> @var: Variable to modify or add. |
| <span style="color:red">`void mini_pwd()`</span>                                         | Displays the current working directory. |



## Question Exercice 5

Avant l'initialisation, il peut y avoir des donn√©es qui √©taient en m√©moire. Pour des raisons de s√©curit√©, en remplissant avec des '\0' la m√©moire qu'on souhaite utiliser, on garantit que n'importe quelle allocation de m√©moire se termine par un terminateur nul, ce qui est utile pour les buffers, √©vitant ainsi des lectures hors limites ou des erreurs lors de la manipulation de cha√Ænes.

## Question Exercice 6

D'apr√®s la d√©finition de `free()` :
"La fonction `free()` en C lib√®re la m√©moire pr√©c√©demment allou√©e dynamiquement avec `malloc()`, `calloc()` ou `realloc()`. Cependant, lorsqu'on appelle `free()`, la m√©moire allou√©e est lib√©r√©e pour √™tre r√©utilis√©e *au sein du m√™me processus*, mais elle n'est pas forc√©ment retourn√©e au syst√®me d'exploitation pour √™tre utilis√©e par d'autres processus. La fonction met √† jour les structures internes de l'allocateur de m√©moire du processus pour marquer cet espace comme disponible pour de futures allocations."

## Question Exercice 17

Quand on affiche un seul caract√®re, les deux conditions d'arr√™t sont lors de la premi√®re saut de ligne ou lorsque le tampon est plein, ce qui peut poser des probl√®mes surtout si la cha√Æne √† afficher n'atteint pas `BUFF_SIZE` et n'avait pas de saut de ligne √† la fin. Il faut donc ajouter une autre condition o√π l'ajout au tampon s'arr√™te et on l'affiche lorsque le caract√®re nul est atteint depuis la cha√Æne pass√©e en param√®tre.

## Question Exercice 20

Si le nombre de caract√®res saisis est √©gal √† la taille du buffer, on aura un probl√®me de "Buffer Overflow", d'o√π il peut y avoir un comportement inattendu ou un "segmentation fault" puisqu'il n'y aura plus de '\0' √† la fin de notre cha√Æne. Pour r√©soudre cela, on prend byte par byte et on arr√™te √† `size_buffer - 1` pour ajouter le '\0'.

## Question Exercice 22

`mini_strlen(char* s)`
Probl√®me : si la cha√Æne d'entr√©e `s` n'est pas termin√©e par un caract√®re nul, la fonction continue de lire la m√©moire au-del√† de la m√©moire allou√©e. Cela garantit que m√™me si `s` n'est pas termin√© par null, la fonction s'arr√™tera apr√®s `max_len` caract√®res.

Explication : En acceptant `dest_size` comme param√®tre, la fonction garantit qu'elle n'√©crit pas plus de caract√®res que la m√©moire tampon de destination ne peut en contenir, y compris le terminateur nul.

En introduisant `max_len`, la fonction √©vite de lire au-del√† de la m√©moire pr√©vue, emp√™chant ainsi un comportement ind√©fini lorsque les cha√Ænes ne sont pas correctement termin√©es par null.

## Question Exercice 33

Si le programme se termine alors que le buffer d‚Äô√©criture n‚Äô√©tait pas plein ?
Lorsque le programme se termine, si le buffer d'√©criture (`buffer_write`) contient des donn√©es non √©crites et qu'il n'est pas plein, ces donn√©es ne seront pas automatiquement √©crites sur le disque. En effet, les donn√©es stock√©es dans le buffer sont en attente d'√™tre √©crites lorsque le buffer sera plein ou lorsqu'une op√©ration de flush est effectu√©e. Si le programme se termine avant que cela ne se produise, les donn√©es restent dans le buffer et sont perdues, ce qui peut entra√Æner une perte de donn√©es et un √©tat incoh√©rent du fichier.

Pour r√©soudre ce probl√®me, il faut s'assurer que tous les buffers d'√©criture des fichiers ouverts sont vid√©s (flush) avant que le programme ne se termine. Cela peut √™tre fait en modifiant la fonction `mini_exit` pour qu'elle effectue les op√©rations suivantes :

- Maintenir une liste des fichiers ouverts : Cr√©er une structure de donn√©es (par exemple, une liste cha√Æn√©e ou un tableau dynamique) qui contient des pointeurs vers tous les objets `MYFILE` repr√©sentant les fichiers actuellement ouverts.
- Flusher tous les fichiers ouverts : Parcourir la liste des fichiers ouverts dans `mini_exit` et appeler `mini_fflush` sur chacun d'eux pour forcer l'√©criture des donn√©es du buffer sur le disque.
- Fermer les fichiers ouverts : Apr√®s le flush, s'assurer que tous les fichiers sont correctement ferm√©s pour lib√©rer les ressources.
